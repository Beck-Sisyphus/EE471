
module CPUcontrol (clk, IMR, flags, intstr2Load, nextPrgCount, prgCount, control);
	input clk, LO, nextPrgCount;
	input [4:0] flags;
	input [31:0] instr2Load;
	output prgCount;
	output [31:0] instr;
	
	assign instr = IMR ? 16'bZ : instr2Load;

	// Instruction Memory
	// Holds the instructions
	InstruMemory memInstr(clk, prgCount, IMR, instr);
	
	// Program Counter Register
	// Stores and Updates the program counter
	ProgCountReg pc(clk, flags, nextPrgCount, prgCount);
	
	// Instruction Decoder
	// Decodes the 32-bit instruction into appropriate control signals
	InstrucDecoder decoder(instr[31:25], OpSel, BSel, DataSel, RegWR, DWR, br);
	
	
	
	
	
	
	
	
	clkSlower counter(slowClk, CLOCK_50, rst);
	registerFile regs(clk, readAdd0, readAdd1, writeAdd, regWR, writeData, readOutput0, readOutput1);
	
	always @(posedge clk) begin
		if(rst) begin
			hold = 0;
			adx = 0;
			WrEn = 1;
			LEDR = 0;
		end else if(state == 0) begin
			WrEn = 0;
			adx = hold;
			store = 7'b1111111 - hold;
			LEDR[6:0] = hold;
		end else if(state == 1) begin
			WrEn = 1;
			regWR = 1;
			writeAdd = hold[4:0];
			adx = blockSel * 32 + hold[4:0]; 
			writeData[15:0] = data;
		end else if(state == 2) begin
			WrEn = 1;
			regWR = 0;
			readAdd0 = hold[3:0];
			readAdd1 = 16 + hold[3:0];
			LEDR = outSel ? readOutput0[9:0] : readOutput1[9:0];
		end else if(state == 3) begin
			WrEn = 0;
			regWR = 0;
			if(blockSel[0]) begin
				readAdd1 = hold[5:2] + 16;
				if(hold[0]) begin 
					store = readOutput1[15:0];
					adx = 179 + hold[5:2];
				end else begin 
					store = readOutput1[15:0];
					adx = 145 + hold[5:2];
				end
			end else begin
				readAdd0 = hold[5:2];
				if(hold[0]) begin 
					store = readOutput0[15:0];
					adx = 162 + hold[5:2];
				end else begin 
					store = readOutput0[15:0];
					adx = 128 + hold[5:2];
				end
			end
		end
		hold = hold + 1'b1;
	end
	

	assign clk = clkControl ? slowClk : CLOCK_50;
	
endmodule 

	reg CLOCK_50;  // connect to system 50 MHz clock
	wire [9:0] LEDR;
	reg [9:0] SW;
	reg [3:0] KEY;
	DE1_SoC dut (CLOCK_50, LEDR, SW, KEY);
	// Set up the clocking
	
	parameter d = 20;
	initial begin
		CLOCK_50 = 1;
		SW = 12;
		KEY = 0;
	end
	
	always #(d/2) CLOCK_50 = ~CLOCK_50;
	

	// Set up the inputs to the design
	initial begin
		#(d*10); SW[9] = 1;
		#d; SW[9] = 0; SW[8] = 1;
		#(d*500); SW[8] = 0;
		#d SW[5:0] = 64;
		#d SW[5:0] = 32;
		#d SW[5:0] = 16;
		#d SW[5:0] = 8;
		#d SW[5:0] = 120;
		$stop;
	end
endmodule 